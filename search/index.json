[{"content":"引入 之前使用webgl实现的波浪效果，只要去除顶点之间连线，渲染顶点圆，其实也可以算是粒子动画。但是那样的方法对于复杂粒子系统动画就有点捉襟见肘了。对于波浪，我们使用不同频率正弦波叠加，传入uniform变量time给gpu。每个顶点都可以简单地计算出每时每刻的位置后，进行顶点变换再渲染。如果系统中粒子要实时响应外部因素变化(如受到速度属性，外部力属性，质量属性)，粒子存在相互作用(碰撞，引力)和模型复杂的时候，我们更希望根据上次粒子的位置，速度属性，递推计算粒子位置变换。这时候就可以使用webgl2的transform feedback功能，将前一帧的位置计算结果写入缓冲区供下一帧计算使用。\n关于webgl2 webgl2包含了许多webgl没有的新特性，支持glsl 3.0 es。\nwebgl2的API获取和glsl编写与webgl主要有以下区别：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //webgl2上下文接口获取 var canvas = document.getElementById(\u0026#34;glcanvas\u0026#34;); const gl2 = canvas.getContext(\u0026#34;webgl2\u0026#34;); //使用glsl 3.0 es //in相当于attribute变量 //out相当于varying变量，可以传递值个fragmentShader const vertexShaderSource = `#version 300 es in vec4 aPosition; out vec4 pos; uniform float deltaTime; void main() { gl_Position = aPosition; } ` //不再使用设置gl_FragColor变量作为输出颜色。 //自己设置out变量作为输出。 const fragmentShaderSource = `#version 300 es out vec4 outColor； void main() { outColor = vec4(1.); } ` webgl2也可以向下兼容webgl，你依旧可以使用webgl的写法。\nwebgl2有许多新的特性可以使用，这里主要变换反馈对象transformFeedback。\n着色器编写 我们来创建一个简单的粒子动画，收到指向固定点恒力的粒子系统。\n我们需要两个gpu程序(即program)，一个用于更新粒子的顶点位置，后写入缓冲区，一个用于渲染，读取顶点位置并渲染。\n由于更新位置的program不需要渲染出来，我们可以在js中停止片段着色器的调用。链接的时候，片段着色器可以链接渲染程序的片段着色器，满足编译要求即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 //读取old位置，速度属性，计算新的位置和速度，赋值给out变量，之后写入缓冲区。 const updateVertexShaderSource = `#version 300 es in vec3 oldPosition; in vec3 oldVelocity; in float mass; uniform vec3 gPoint; uniform float gForce; uniform float deltaTime; out vec3 newPosition; out vec3 newVelocity; void main() { float dt = deltaTime / 1000.; newPosition = oldPosition + oldVelocity * dt; vec3 a = normalize(gPoint - newPosition) * gForce / mass; newVelocity = oldVelocity + a * dt; if(length(newPosition - gPoint) \u0026lt;= 0.1) { newVelocity = oldVelocity - 5. * a * dt; } } ` //渲染点的俩个着色器。 const renderVertexShaderSource = `#version 300 es in vec4 a_position; uniform mat4 mvp; void main() { gl_Position = mvp * a_position; gl_PointSize = 5.; } ` const renderFragmentShaderSource = `#version 300 es precision highp float; out vec4 outColor; void main() { vec2 coord = gl_PointCoord - vec2(0.5); float dist = length(coord); if(dist \u0026gt; 0.43) { discard; } outColor = vec4(1.0, 0.7, 0.7, 1.0); outColor.a *= 1.0 - smoothstep(0.4, 0.5, dist); } ` 设置transformFeedback 设置transformFeedbackVarying 要设置transformFeedback，需要在使用shaderSource创建好shader，创建program并把shader附加到program后，通过transformFeedbackVaryings函数告诉gpu，哪些out变量要写入缓冲区。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const updateVertexShader = WebglUtil.createShader(gl2, gl2.VERTEX_SHADER, updateVertexShaderSource); const renderVertexShader = WebglUtil.createShader(gl2, gl2.VERTEX_SHADER, renderVertexShaderSource); const renderFragmentShader = WebglUtil.createShader(gl2, gl2.FRAGMENT_SHADER, renderFragmentShaderSource); const updateProgram = gl2.createProgram(); gl2.attachShader(updateProgram, updateVertexShader); gl2.attachShader(updateProgram, renderFragmentShader); gl2.transformFeedbackVaryings( updateProgram,//指定program [\u0026#39;newPosition\u0026#39;, \u0026#39;newVelocity\u0026#39;],//指定变量 gl2.SEPARATE_ATTRIBS//变量将被写入不同缓冲区 ); gl2.linkProgram(updateProgram); if(!gl2.getProgramParameter(updateProgram, gl2.LINK_STATUS)) { throw new Error(gl.getProgramParameter(updateProgram)); } 设置transformFeedback buffer 接下来设置要写入的缓冲区。我们使用双缓冲区，以更新位置属性为例，一个存储旧位置用于读取，计算后写入另一个缓冲区。计算好新位置和渲染了旧位置后，交换用于读写缓冲区的指针指向，就可以循环计算每一帧的位置了。可以编写以下函数返回一个匿名类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function createDoubleBuffer() { return { write : gl2.createBuffer(), read : gl2.createBuffer(), swap : function(){ const temp = this.write; this.write = this.read; this.read = temp; } } } var positionDoubleBuffer = createDoubleBuffer(); gl2.bindBuffer(gl2.ARRAY_BUFFER, positionDoubleBuffer.write); gl2.bufferData(gl2.ARRAY_BUFFER, 120000, gl2.DYNAMIC_DRAW);//设置缓冲区大小 gl2.bindBuffer(gl2.ARRAY_BUFFER, null);//解除引用。 创建完双缓冲区后，进行以下操作：\n1 2 3 4 const tf = gl2.createTransformFeedback(); gl2.bindTransformFeedback(gl2.TRANSFORM_FEEDBACK, tf); gl2.bindBufferBase(gl2.TRANSFORM_FEEDBACK_BUFFER, 0, positionDoubleBuffer.write); gl2.bindBufferBase(gl2.TRANSFORM_FEEDBACK_BUFFER, 1, velocityDoubleBuffer.write); 在渲染循环中启用transformFeedback 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 function draw(currentTime)//渲染循环函数 { //初始化 gl2.viewport(0, 0, canvas.width, canvas.height); gl2.clearColor(0., 0., 0., 1.0); gl2.clearDepth(1.0); gl2.enable(gl2.DEPTH_TEST); gl2.clear(gl2.COLOR_BUFFER_BIT | gl2.DEPTH_BUFFER_BIT); //先绘制旧位置 gl2.useProgram(renderProgram); //设置相关属性和uniform。 //... gl2.drawArrays(gl2.POINTS, 0, 10000); //再更新属性 gl2.useProgram(updateProgram); gl2.enable(gl2.RASTERIZER_DISCARD);//不调用片段着色器。 //设置相关属性和uniform。 //... gl2.bindTransformFeedback(gl2.TRANSFORM_FEEDBACK, tf); gl2.beginTransformFeedback(gl2.POINTS); gl2.drawArrays(gl2.POINTS, 0, 10000); gl2.endTransformFeedback(); gl2.bindTransformFeedback(gl2.TRANSFORM_FEEDBACK, null); gl2.disable(gl2.RASTERIZER_DISCARD);//允许调用片段着色器。 //交换读写缓冲区。 positionDoubleBuffer.swap(); velocityDoubleBuffer.swap(); //重新设置相关属性的缓冲区引用。 //... } 效果(cameraZ为0有bug) ","date":"2025-08-25T17:45:23+08:00","permalink":"https://reimunai.github.io/p/webgl%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB/","title":"webgl实现简单粒子动画"},{"content":"之前写关于C#的博客发现在对应markdown文档里插入图片，在构建成静态网站后并不能加载出来。\n先是重新构建，不行。\n改变图片格式，不行。\n\u0026hellip;\n最后是在浏览器按F12看报错发现，发现试图加载图片的路径是http://websize/p/c。而我文件里有p/c#XXXX，根据我的文章titile生成的。#后面的都不见了。我在文件命名是已经避免了特殊符号，没想到是hugo生成的文件有特殊符号，可能#号是在这个hugo网站模板有特殊的解析方式，导致读取图片的时候路径错误。不过我也不敢用ai教的胡乱该模板原代码，只能在title避免#号了。\n","date":"2025-08-19T13:13:05+08:00","image":"https://reimunai.github.io/p/%E5%85%B3%E4%BA%8Ehugo%E7%9A%84%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%A2%8E%E5%BF%B5/image_hu_a58159332337656d.png","permalink":"https://reimunai.github.io/p/%E5%85%B3%E4%BA%8Ehugo%E7%9A%84%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%A2%8E%E5%BF%B5/","title":"关于hugo的一些碎碎念"},{"content":"C#委托 介绍 在C#里委托是一种类型安全的函数指针，类似于C/C++中的函数指针，相当于C#的引用之于C/C++的指针一样，提供类似指针的操作，但是更加安全。\n且委托允许指向多个函数，即多播。\n语法 委托的声明。\n1 2 3 4 //委托声明 public delegate 返回类型 委托名(参数列表); //如下 public delegate int MathOperation(int x, int y); 在声明委托之后，通过new来实例化一个委托。之后就可以通过委托来调用其引用的函数。\n1 2 3 4 5 6 7 8 9 10 //委托声明 public delegate int MathOperation(int x, int y); public int add(int x, int y) { return x + y; } //实例化时，构造参数不能为空。 MathOperation mo = new MathOperation(add); int res = mo(3, 5); //res = 8 相同类型的委托可以进行合并。让所有委托时调用多个函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //续之前代码 int a = 1; public delegate void ChangeA(int b); public void add(int b) { a += b; } public void multi(int b) { a *= b } ChangeA ca; ChangeA ca1 = new ChangeA(add); ChangeA ca2 = new ChangeA(multi); ca = ca1; ca += ca2; ca(5); //a = 30; 委托还可以通过-=来移除引用的函数。\n1 ca -= multi; 委托可以作为函数参数。\n1 2 3 4 5 //如 public int testFunc(int a, MathOperation mo) { return mo(a, a); } 其他 C#提供了几种常见的泛型委托类型，可以使用这些直接实例化常见的委托。\n1 2 3 4 5 6 7 8 //Action表示不返回值的函数，最多接收16个参数。 public Action\u0026lt;string, int\u0026gt; action = func; //Action表示有返回值的函数，最多接收16个参数。 //只有一个泛型参数时，代表返回值类型。 //多个时最后一个为返回类型，其他为输入类型。 public Func\u0026lt;int, int, int\u0026gt; addFunc = func; //Predicate表示返回bool值的函数，泛型参数为输入类型。 public Predicate\u0026lt;int, int\u0026gt; isTrue = func; 另外C#匿名函数的使用也会使用delegate关键字。或者类似C++11Lambda表达式那样更简洁的写法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //在需要函数(即委托)作为参数时，可以直接使用匿名函数。 public void test(Func\u0026lt;int, int\u0026gt; func) { console.writeLine(func(2)); } //delegate关键字创建匿名函数。 test(delegate(int a){return a * a;}); test(delegate(int a){return a + 5;}); //lambda表达式创建匿名函数 test((int a) =\u0026gt; {return a * a;}); test((int a) =\u0026gt; a * a); //输出: //4 //7 但是因为匿名函数是没有名字的函数，所以如果在委托中添加一个匿名函数，是没办法减掉这个匿名函数的。\n如果匿名函数中使用了外部函数的变量，可能导致该变量的生命周期延长，产生异常结果。可以使用static声明不捕获外部变量的匿名函数。\nC#事件 介绍 知道了委托的用处，第一反应就是可以用于游戏中的事件处理。\n但是同时会发现使用委托实现观察者模式(又名发布-订阅模式，我个人更喜欢这个名字)，特别是一个发布，多个订阅时，会发现委托不能直接添加函数，添加订阅时需要创建多个委托后进行合并，比较麻烦。其实C#已经提供了实现发布-订阅模式，且使用方便的事件类型。\nC#事件就是对委托进行了封装，来实现发布-订阅模式的一个类型。\n语法 1 2 3 4 5 6 7 8 9 10 //声明事件之前，需要声明该事件的委托类型(即该事件发生时调用什么样的函数)。 public delegate void testHandler(string args); //再基于声明的委托定义事件。 public event testHandler Ontest; //事件的触发,事件只能在定义事件类里面触发即事件由发布者发布。 //？用于检查事件中委托引用的函数是否为空，保证只要有订阅者才触发。 Ontest?.Invoke(s); //事件的订阅和取消订阅。提供-=，+= Ontest += funcName; Ontest -= funcName; 完整的发布-订阅模式实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 //事件的委托类型经常命名为XXHandler public delegate void testHandler(string args); //发布者 public class Pulisher { public event testHandler Ontest; public void OntestInvoke(string a) { Ontest?.Invoke(s); } //模拟事件的触发 public void StartTest() { OntestInvoke(\u0026#34;sss\u0026#34;); } } //订阅者 public class subscriber { public void subscribe(Pulisher pulisher) { pulisher.Ontest += react; } //订阅者对事件发生做出反应 private void react(string s) { Console.WriteLine(s); } } static void main(sting[] args) { Pulisher p = new Pulisher(); subscriber s = new subscriber(); s.subscribe(p); subscriber s1 = new subscriber(); s1.subscribe(p); //多个订阅者 //事件触发 p.StartTest(); //输出： //sss //sss //做出了反应。 } unityEvent 发布-订阅模式是游戏中常用的设计模式，robloxstudio和godot都提供了在编辑器配置事件的方法，unity也有相关功能。\nunityEvent是unity提供的对事件操作的api，unityevent允许在inspector直接添加或者删除订阅者函数，简化了代码的书写。\n1 2 3 4 5 6 7 8 9 10 11 using UnityEngine.Events; public class tester : MonoBehavior { public UnityEvent unityEvent; //模拟事件触发 public void Invoke() { unityEvent?.Invoke(); } } 这样就可以在inspector看见类似button的onclick的事件ui。\n想要带有参数需要重载unityEvent\u0026lt;T0\u0026gt;,unityEvent\u0026lt;T0, T1\u0026gt; 抽象类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using UnityEngine.Events; [Serializable] public class FloatEvent : UnityEvent\u0026lt;float\u0026gt;{}; public class tester : MonoBehavior { public UnityEvent unityEvent; public FloatEvent floatEvent; //模拟事件触发 public void Invoke() { unityEvent?.Invoke(); } public void FloatInvoke() { FloatEvent?.Invoke(0.5f); } } 也可以在代码中添加和删除监听\n1 2 unityEvent.AddListener(funcName); unityEvent.RemoveListener(funcName); 相关链接:\n委托的菜鸟教程相关页面。\n事件的菜鸟教程相关页面。\n匿名函数和lambda菜鸟教程相关页面。\nCSDN,匿名函数和lambda。\nCSDNunity事件。\nUnity官方，UnityEvent相关文档手册部分和脚本API部分。\n","date":"2025-08-17T22:28:25+08:00","image":"https://reimunai.github.io/p/csharp%E4%B8%AD%E7%9A%84%E5%A7%94%E6%89%98%E4%BA%8B%E4%BB%B6%E5%92%8Cunity%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B/image_hu_4f9b705beb782405.png","permalink":"https://reimunai.github.io/p/csharp%E4%B8%AD%E7%9A%84%E5%A7%94%E6%89%98%E4%BA%8B%E4%BB%B6%E5%92%8Cunity%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B/","title":"Csharp中的委托，事件和Unity中的特殊事件类型"},{"content":"Json方案 简介 JSON: JavaScript Object Notation(JavaScript 对象表示法)\nJSON是存储和交换文本信息的语法，类似 XML。JSON比 XML 更小、更快，更易解析。 JSON易于人阅读和编写。C、Python、C++、Java、PHP、Go 等编程语言都支持 JSON。\n方法 文件读写 在unity进行json文件读写操作需要引入命名空间System.IO中的File类。使用其中相关静态函数。\n1 2 3 4 5 using System.IO; //写入 File.WriteAllText(string path, string text, json); //读取 string json = File.ReadAllText(string path); 存储位置 Application.persistentDataPath\n适用于保存需要长期保留的用户数据（如设置、进度、关卡数据等）。\n在各平台上的实际路径不同，但都在应用可写的目录。\n转为json字符串 将数据转换为Json字符串使用unity提供的类JsonUtility中的静态函数。\n1 2 3 4 //转换为json。 string json = JsonUtility.ToJson(object obj, bool prettyPrint = false); //转换为对象。 Data data = JsonUtility.FromJson\u0026lt;Data\u0026gt;(string json); 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 using System.IO; public static class JsonHelper { public static void SaveJson(string path, object obj) { string finalPath = Application.persistentDataPath + \u0026#34;/\u0026#34; + path; //或者string finalPath = Path.Combine(Application.persistentDataPath, path); string jsonData = JsonUtility.ToJson(obj, true); //可以在write这里进行适当的错误处理 File.WriteAllText(finalPath, jsonData, json); } public static T LoadJson\u0026lt;T\u0026gt;(string path) { string finalPath = Application.persistentDataPath + \u0026#34;/\u0026#34; + path; if(File.Exists(finalPath)) { string jsonData = File.ReadAllText(path); //担心转换的对象有问题可以在这里进行适当的错误处理。 return JsonUtility.FromJson\u0026lt;T\u0026gt;(jsonData); } } } 注意 限制 JsonUtility.ToJson支持任何普通类和结构体，和派生自MonoBehaviour或scriptableOnject的类。且只支持其中unity受序列化器支持的字段。虽然可以将C#原始类型传入，但是只会在Json中生成空对象字段。\n虽然ToJson方法支持派生自MonoBehaviour或scriptableOnject的类，但是JsonUtility.FromJson只支持创建普通类和结构；不支持派生自UnityEngine.Object的类（如MonoBehaviour或ScriptableObject）。\n如果想从Json读取并创建或者覆写怕派生自UnityEngine.Object的类，可以额外创建一个只包含数据的普通类，再提供这个数据类进行对象的创建或者覆写。\n或者想对更多数据类型的支持，如字典，列表等，可以使用其他的api如Newtonsoft.Json（Json.NET）— 适合更复杂的结构。\n优点：支持字典、列表、嵌套对象等，序列化选项灵活。\n","date":"2025-08-16T20:40:49+08:00","image":"https://reimunai.github.io/p/unity%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/image_hu_4f9b705beb782405.png","permalink":"https://reimunai.github.io/p/unity%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/","title":"Unity数据持久化存储"},{"content":"场景中物体类的编写 相机 定义相机类，包含其位置，观察位置，向上方向的属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Camera { constructor( position = [0.0, 0.0, 1.0], gazePosition = [0.0, 0.0, 0.0], viewUpVector3 = [0.0, 1.0, 0.0], viewPort = {width: 1.0, height: 1.0, d: 1.0} ) { this.position = position; this.gazePosition = gazePosition; this.viewUpVector3 = viewUpVector3; this.viewPort = viewPort; } } 还有获取变换到视图空间和到裁切空间的两个矩阵的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //续以上类中代码 getViewMatrix() { const res = mat4.create(); mat4.lookAt(res, this.position, this.gazePosition, this.viewUpVector3); return res; } getProjectionMatrix(canvas) { const res = mat4.create(); mat4.perspectiveNO(res, this.fovy, canvas.clientWidth / canvas.clientHeight, this.near, this.far); return res; } 平面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class PlaneMesh { constructor( position = [0.0, 0.0, 0.0], size = [5, 5],//大小 sub = 20,//细分等级 rotateXYZ = [0, 0, 0]//旋转，默认朝向Z ) { this.position = position; this.size = size; this.sub = sub; this.rotateXYZ = rotateXYZ; } } 由于渲染需要面的顶点，同时想要渲染模拟水面效果需要面具有尽量多的顶点属性中定义了面的细分等级。\n现在还需要一个方法可以获取面的所有顶点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 //续以上类中代码 getVertexData() { var data = []; var meshCoordSize = []; meshCoordSize[0] = this.size[0] / (this.sub + 1); meshCoordSize[1] = this.size[1] / (this.sub + 1); for(var i = 0; i \u0026lt; (this.sub + 1); i++) { var p1 = [0, i * meshCoordSize[1], 0]; var p2 = [0, (i+ 1) * meshCoordSize[1], 0]; var p3 = [p1[0] + meshCoordSize[0], p1[1], 0]; for(var j = 0; j \u0026lt; ((this.sub + 1) * 2); j++) { data.push(p1[0], p1[1], p1[2]); data.push(p2[0], p2[1], p2[2]); data.push(p3[0], p3[1], p3[2]); p1 = p2; p2 = p3; if(p1[0] == p2[0]) { p3 = [p1[0] + meshCoordSize[0], p1[1], 0]; } else { p3 = [p2[0], p2[1] + meshCoordSize[1], 0]; } } } var res = new Float32Array(data); return res; } 以上代码生成的坐标是四边形一角放在原点，在第一象限且两个邻边对齐坐标轴，之后还要进行矩阵变换到对应position和rotateXYZ。 webgl中面按三角面渲染，顶点数据会有重复顶点。其实可以通过顶点索引数据来避免顶点数据重复，但是同样位置的顶点在不同的面可能具有不同的顶点颜色和法线，视情况而定。这里采用重复情况。\n同时顶点的读取要满足三个三个构成正确的三角形，要注意顶点填入的顺序。这里参考webgl，drawArray函数绘制TRIANGLES_STRIP情况下的绘制顺序填入。\n既对于ABCDEF点,先填入ABC，然后BCD，CDE和DEF共4个三角面。\nhtml环境配置 创建canvas和获取webgl上下文 1 2 3 4 5 6 7 8 \u0026lt;body\u0026gt; \u0026lt;canvas id=\u0026#39;glcanvas\u0026#39; width=\u0026#39;1920\u0026#39; heigth=\u0026#39;1080\u0026#39; style=\u0026#39;border: 2px solid black;\u0026#39;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; const canvas = document.getElementById(\u0026#34;glcanvas\u0026#34;); const gl = canvas.getContext(\u0026#39;webgl\u0026#39;); \u0026lt;/script\u0026gt; 着色器的创建，编译和链接 创建着色器资源 通过以下代码创建着色器资源\n1 2 3 4 5 6 7 const vertexShaderSource = ` 你的顶点着色器代码 ` const fragmentShaderSource = ` 你的片员着色器代码 ` 着色器创建，编译 1 2 3 4 5 const shader = gl.createShader(type); //type为gl.VERTEX_SHADER,gl.FRAGMENT_SHADER gl.shaderSource(shader, source); gl.compileShader(shader); gl.getShaderParameter(shader, gl.COMPILE_STATUS); 链接,创建program 1 2 3 4 const program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); 以上代码在各个项目可以多次使用，可以封装为函数写在mjs文件中。\n创建渲染场景 实例化上文创建的Camera类，PlaneMesh类。如果可以也可以创建并实例化灯光类。\n1 2 3 const camera = new Camera(); const plane = new PlaneMesh(); // const light = new Light(); 渲染循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 function draw(currentTime) { gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); gl.clearColor(1.0, 1.0, 1.0, 1.0); gl.enable(gl.DEPTH_TEST); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); gl.useProgram(program); //变换矩阵的计算 const m = mat4.create(); const v = camera.getViewMatrix(); const p = camera.getProjectionMatrix(canvas); const m_mvp = mat4.create(); mat4.multiply(m_mvp, v, m); mat4.multiply(m_mvp, p, m_mvp); //配置program中着色器的uniform和attribute //其他配置 gl.drawArrays(mode, first, count); } function render(currentTime) { draw(currentTime); requestAnimationFrame(render); } render(); 配置program中着色器的uniform和attribute uniform 1 2 3 4 //示例 const uniformLoc = gl.getUniformLocation(program, \u0026#34;着色器中对应变量名\u0026#34;); gl.uniform1f(uniformLoc, 数据); //1f为float；2f，3f和4f为vec2，vec3和vec4；Matrix4f是4 x 4矩阵；1fv加一个v是数组 attribute 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //示例 const positionBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW); const positionAttribLoc = gl.getAttribLocation(program, \u0026#39;a_position\u0026#39;); gl.enableVertexAttribArray(positionAttribLoc); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.vertexAttribPointer( positionAttribLoc, 3, gl.FLOAT, false, 0, 0 ); 封装 以上代码根据着色器需要的参数有长有短，一般情况就需要顶点位置，颜色，法线和mvp变换矩阵。 所以可以和着色器资源封装在一起，简化调用，提高可读性。如下：\n1 2 3 4 5 6 7 8 9 //配置代码 const waveUniformInfoLoc = waveShader.getuniformInfoLoc(gl, program); const waveUniformInfo = { mvp : m_mvp, resolution : [gl.canvas.width, gl.canvas.height], time : currentTime }; waveShader.setAttribute(gl, program, vertexData); waveShader.setUniformInfo(gl, waveUniformInfoLoc, waveUniformInfo); 着色器shader代码编写 顶点着色器vertexShader 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 const vertexShaderSource = ` attribute vec3 a_position;//顶点 uniform mat4 u_mvp;//mvp变换矩阵 uniform float u_time; //顶点颜色和法线 varying vec3 vColor; varying vec3 vNormal; float computeWaveHeight(vec2 pos, float time) { float height = 0.; height += sin(pos.x * 3. + time * 1.5) * 2.; height += sin(pos.x * 3. + pos.y * 1.2 + time * 1.5) * 3.; return height; } vec3 calculateNormal(vec3 pos, float time) { float eps = 0.1; // 使用中心差分法计算法向量 float hL = computeWaveHeight(vec2(pos.x - eps, pos.z), time); float hR = computeWaveHeight(vec2(pos.x + eps, pos.z), time); float hD = computeWaveHeight(vec2(pos.x, pos.z - eps), time); float hU = computeWaveHeight(vec2(pos.x, pos.z + eps), time); vec3 normal = normalize(vec3(hL - hR, 2.0 * eps, hD - hU)); return normal; } void main(){ vec3 wavePosition = a_position; wavePosition.y += computeWaveHeight(wavePosition.xz, u_time) ; vNormal = calculateNormal(wavePosition, u_time);//法线计算 //因为没有传入光照参数就直接在这里写了，假设点光在(0, 10, 0) vec3 l = normalize(vec3(0., 10., 0) - wavePosition);//光线方向 float zita = dot(vNormal, l);//角度计算 float I = max(cos(zita), 0.);//简单的光强计算 vColor = mix(vec3(0., 0., 0.5), vec3(0.7, 0.7, 1.), I);//根据光强混合顶点颜色 gl_Position = u_mvp * vec4(wavePosition, 1.0); } ` 片元着色器fragShader 1 2 3 4 5 6 7 8 9 10 const fragmentShaderSource = ` precision mediump float; varying vec3 vColor; varying vec3 vNormal; void main() { gl_FragColor = vec4(vColor, 1.0); } `; 最终效果 可以把plane的大小，旋转，细分，相机位置，观察位置和着色器中计算浪高的参数暴露出来，使用html的lable 和input修改来调整画面到想要的效果。\n遇到的问题 变换矩阵计算 计算变换到NDC空间的矩阵是由从模型空间-\u0026gt;世界空间-\u0026gt;视图空间-\u0026gt;透视裁剪空间三次变换。\n分别使用modelMatrix，viewMatrix，ProjectionMatrix，乘在一起叫mvp矩阵。\n写成式子应该是 $P\\times V\\times M\\times vertexPoint$,顺序出错会导致变换出问题，看不到内容。\n也有可能是计算各个矩阵时参数没有设定好，如使用glmatrix库，计算透视ProjectionMatrix，near和far参数应该是大于0的数，且far \u0026gt; near。\n模糊问题 最开始在canvas属性的设置中，没看清代码，只设置CSSstyle中的width，height。 但是应该设置canvas的html属性，这个才是和分辨率相关的。CSSstyle的是画布的物理尺寸和分辨率无关。\n1 2 3 4 //正确写法 \u0026lt;canvas id=\u0026#34;glcanvas\u0026#34; style=\u0026#34;border: 2px solid black;\u0026#34; width=\u0026#34;1920\u0026#34; height=\u0026#34;1080\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; //错误写法 \u0026lt;canvas id=\u0026#34;glcanvas\u0026#34; style=\u0026#34;border: 2px solid black; width: 100%; heigth: 100%\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; 相关链接:\n本文矩阵计算使用glmatrix。\nwebgl代码及代码组织学习自MDN Web Docs和webgl基础\n","date":"2025-08-10T23:31:11+08:00","image":"https://reimunai.github.io/p/webgl%E6%B8%B2%E6%9F%93%E6%B0%B4%E9%9D%A2%E6%B3%A2%E6%B5%AA/image-3_hu_3bbd4ba14f6c4388.png","permalink":"https://reimunai.github.io/p/webgl%E6%B8%B2%E6%9F%93%E6%B0%B4%E9%9D%A2%E6%B3%A2%E6%B5%AA/","title":"webgl渲染水面波浪"},{"content":"测试 ","date":"2025-08-08T21:15:37+08:00","permalink":"https://reimunai.github.io/p/testblog/","title":"TestBlog"}]